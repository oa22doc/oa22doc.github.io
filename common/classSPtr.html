<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/html40/loose.dtd">

<!-- start header -->

<html><head>

<title>SPtr Class Reference</title>
<link href="../style.css" rel="stylesheet" type="text/css">

<link href="../tabs.css" rel="stylesheet" type="text/css">

<link href="../print.css" rel="stylesheet" type="text/css" media="print">

</head>

<body bgColor='#ffffff'><a name='pagetop'></a>

<div id="navigation">

<table border='0' cellpadding='0' cellspacing='0' width = "760">

  <tr>

    <td><img src="../oaheader.gif" alt="../oaheader.gif"></td>

  </tr>

</table>

<table border='0' cellpadding='0' cellspacing='0' width = "760">

  <tr>

    <td width = "95" height = "30"><a href="../index.html"><img src='../topics.gif' alt='../topics.gif' width = "95" height = "30" border="0" align="top"></a></td>

    <td width = "95" height = "30"><a href="../classes.html"><img src='../classes_all.gif' alt='../classes.gif' width = "95" height = "30" border="0"></a></td>

    <td width = "95" height = "30"><a href="../classes_sel.html"><img src='../classes_sel.gif' alt='../classes.gif' width = "95" height = "30" border="0"></a></td>

    <td width = "95" height = "30" ><a href="../exceptionsByName.html"><img src='../exceptions.gif' alt='../exceptions.gif' border="0" ></a></td>

    <td width = "95" height = "30"><a href="../guide/index.html"><img src='../progguide.gif' alt='../progguide.gif' width = "95" height = "30" border="0"></a></td>

    <td width = "95" height = "30"><a href="../schema/schematoc.html"><img src='../infomodel.gif' alt='../infomodel.gif' width = "95" height = "30" border="0"></a></td>

    <td width = "95" height = "30"><a href="../doc_index.html"><img src='../index.gif' alt='../index.gif' width = "95" height = "30" border="0"></a></td>

    <td width = "95" height = "30"><a href="../help.html"><img src='../help.gif' alt='../help.gif' border="0" ></a></td>

  </tr>

  <tr>

    <td width = "95" height = "20"></td>

    <td width = "95" height = "20"></td>

    <td width = "95" height = "20"></td>

    <td width = "95" height = "20"></td>

    <td width = "95" height = "20"></td>

    <td width = "95" height = "20"></td>

    <td width = "95" height = "20"></td>

    <td width = "95" height = "20"></td>

  </tr>

</table>

</div>

<p>

<!-- end header -->

<!-- Generated by Doxygen 1.3-rc2 -->
<h1>SPtr Class Template Reference</h1><p>Inheritance diagram for SPtr:
<p><center><img src="classSPtr.png" usemap="#SPtr_map" border="0" alt=""></center>
<map name="SPtr_map">
<area href="classSQPtr.html" alt="SQPtr" shape="rect" coords="0,56,46,80">
</map>
<p> </p> 
<table cellspacing="0" cellpadding="1" border="0" bordercolor="#ffffff"> 
<tr bgcolor="#000099"> 
<td> <a href="classSPtr-members.html"><img src="../members.gif" border="0"></a></td>
</tr>
</table>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td></td></tr>
<tr><td colspan=2><br><h2>Public Methods</h2></td></tr>
<tr><td nowrap align=right valign=top>&nbsp;</td><td valign=bottom><a class="el" href="classSPtr.html#a0">SPtr</a> ()</td></tr>
<tr><td nowrap align=right valign=top>&nbsp;</td><td valign=bottom><a class="el" href="classSPtr.html#a1">SPtr</a> (T *in)</td></tr>
<tr><td nowrap align=right valign=top>&nbsp;</td><td valign=bottom><a class="el" href="classSPtr.html#a2">SPtr</a> (const char *classID, bool factory=false)</td></tr>
<tr><td nowrap align=right valign=top>&nbsp;</td><td valign=bottom><a class="el" href="classSPtr.html#a3">SPtr</a> (const <a class="el" href="classSRef.html">SRef</a>&lt; T &gt; &amp;in)</td></tr>
<tr><td nowrap align=right valign=top>&nbsp;</td><td valign=bottom><a class="el" href="classSPtr.html#a4">SPtr</a> (const SPtr&lt; T &gt; &amp;in)</td></tr>
<tr><td nowrap align=right valign=top>&nbsp;</td><td valign=bottom><a class="el" href="classSPtr.html#a5">~SPtr</a> ()</td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classSPtr.html#a6">release</a> ()</td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="classSPtr.html#a7">createInstance</a> (const char *classID, <a class="el" href="classIBase.html">IBase</a> *reserved=NULL)</td></tr>
<tr><td nowrap align=right valign=top>&nbsp;</td><td valign=bottom><a class="el" href="classSPtr.html#a8">operator T *&amp;</a> () const</td></tr>
<tr><td nowrap align=right valign=top>T *&nbsp;</td><td valign=bottom><a class="el" href="classSPtr.html#a10">operator-&gt;</a> () const</td></tr>
<tr><td nowrap align=right valign=top>T *&nbsp;</td><td valign=bottom><a class="el" href="classSPtr.html#a11">operator=</a> (T *in)</td></tr>
<tr><td nowrap align=right valign=top>T *&nbsp;</td><td valign=bottom><a class="el" href="classSPtr.html#a12">operator=</a> (const SPtr&lt; T &gt; &amp;in)</td></tr>
<tr><td nowrap align=right valign=top>T *&nbsp;</td><td valign=bottom><a class="el" href="classSPtr.html#a13">operator=</a> (const <a class="el" href="classSRef.html">SRef</a>&lt; T &gt; &amp;in)</td></tr>
<tr><td nowrap align=right valign=top>bool&nbsp;</td><td valign=bottom><a class="el" href="classSPtr.html#a14">operator&lt;</a> (const SPtr&lt; T &gt; &amp;in) const</td></tr>
<tr><td nowrap align=right valign=top><b>template&lt;class U&gt; </b>bool&nbsp;</td><td valign=bottom><a class="el" href="classSPtr.html#a15">operator==</a> (const SPtr&lt; U &gt; &amp;in) const</td></tr>
<tr><td nowrap align=right valign=top><b>template&lt;class U&gt; </b>bool&nbsp;</td><td valign=bottom><a class="el" href="classSPtr.html#a16">operator!=</a> (const SPtr&lt; U &gt; &amp;in) const</td></tr>
<tr><td nowrap align=right valign=top>T *&nbsp;</td><td valign=bottom><a class="el" href="classSPtr.html#a17">detach</a> ()</td></tr>
<tr><td nowrap align=right valign=top>T *&nbsp;</td><td valign=bottom><a class="el" href="classSPtr.html#a18">getRef</a> ()</td></tr>
<tr><td nowrap align=right valign=top>T *&nbsp;</td><td valign=bottom><a class="el" href="classSPtr.html#a19">ptr</a> () const</td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
<h3>template&lt;class T&gt;<br>
 class SPtr&lt; T &gt;</h3>

This class is the OpenAccess plug-in system smart pointer implementation. It manages the lifetime of plug-in instances that are being used by clients. This is accomplished by the interaction between the <code>SPtr</code> class and the reference count of the plug-in, the latter being accessed through the <code><a class="el" href="classIBase.html#a1">IBase::addRef</a></code> and <code><a class="el" href="classIBase.html#a2">IBase::release</a></code> member functions. The high level model of the SPtr is that it adds a reference to a component in its constructor, and releases it in the destructor. However, it also has member functions that allow it to work properly as the target in an output parameter, and the assignee in an <a class="el" href="classSRef.html">SRef</a> return value. There are constructors that accomplish various tasks within the plug-in system (see individual descriptions), and operators for testing and comparisons (again, see individual descriptions).
<p>
It is highly reccommended that clients use either an SPtr or <a class="el" href="classSQPtr.html">SQPtr</a> (see below) to hold pointers to interfaces. Among the advantages of using the smart pointer classes is the fact that they clean up the references to any outstanding plug-in interfaces in the case of an exception being thrown through or out of the function holding the interface pointer(s). 
<p>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a name="a0" doxytag="SPtr::SPtr"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
<b>template&lt;class T&gt; </b></td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> <b>SPtr&lt; T &gt;::SPtr</b> </td>
          <td class="md" valign="top"><b>(&nbsp;</b></td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top"><b>)&nbsp;<b></td>
          <td class="md" nowrap><b></b><code><b> [inline]</b></code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This is the default constructor for the <code>SPtr</code> class. It initializes the internal pointer to <code>NULL</code>.     </td>
  </tr>
</table>
<a name="a1" doxytag="SPtr::SPtr"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
<b>template&lt;class T&gt; </b></td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> <b>SPtr&lt; T &gt;::SPtr</b> </td>
          <td class="md" valign="top"><b>(&nbsp;</b></td>
          <td class="md" nowrap valign="top"><b>T *</b>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;<b> <em>in</em>          </td>
          <td class="md" valign="top"><b>)&nbsp;<b></td>
          <td class="md" nowrap><b></b><code><b> [inline]</b></code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This constructor takes in a raw interface pointer. It adds a reference to the instance (via the <code><a class="el" href="classIBase.html#a1">IBase::addRef()</a></code> function) and stores the pointer value in its internal pointer field.
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>in</em>&nbsp;</td><td>A pointer to an interface of type <code>T</code>. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a name="a2" doxytag="SPtr::SPtr"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
<b>template&lt;class T&gt; </b></td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> <b>SPtr&lt; T &gt;::SPtr</b> </td>
          <td class="md" valign="top"><b>(&nbsp;</b></td>
          <td class="md" nowrap valign="top"><b>const char *</b>&nbsp;</td>
          <td class="mdname" nowrap>&nbsp;<b> <em>classID</em>, </b></td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><b>bool</b>&nbsp;</td>
          <td class="mdname" nowrap>&nbsp;<b> <em>factory</em> = false</td>
        </tr>
        <tr>
          <td></td>
          <td class="md"><b> )&nbsp;</b></td>
          <td class="md" colspan="2"><b></b><code><b> [inline]</b></code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This constructor takes in the name of a plug-in. It passes this name to the plug-in manager to create a new instance of the requested plug-in. It requests an interface pointer of type <code>T</code>. If the plug-in does not implement that interface, the new plug-in instance will be deleted, and the internal pointer of the <code>SPtr</code> is set to <code>NULL</code>.
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>classID</em>&nbsp;</td><td>A <code>NULL</code> terminated string representing the name of the plug-in to create.</td></tr>
    <tr><td valign=top><em>factory</em>&nbsp;</td><td>If this parameter is set to <code>true</code>, the <code>SPtr</code> will request a pointer to the plug-in's factory* instead of the plug-in itself. This factory must implement the interface <code>T</code>. This is useful if the factory implements a custom creation interface, or some other interface that is relevent to all instances of this plug-in type (for example, licensing or authorization). </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a name="a3" doxytag="SPtr::SPtr"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
<b>template&lt;class T&gt; </b></td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> <b>SPtr&lt; T &gt;::SPtr</b> </td>
          <td class="md" valign="top"><b>(&nbsp;</b></td>
          <td class="md" nowrap valign="top"><b>const <a class="el" href="classSRef.html">SRef</a>&lt; T &gt; &amp;</b>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;<b> <em>in</em>          </td>
          <td class="md" valign="top"><b>)&nbsp;<b></td>
          <td class="md" nowrap><b></b><code><b> [inline, explicit]</b></code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This constructor takes in an <code><a class="el" href="classSRef.html">SRef</a></code> of a matching interface type. This is usually invoked when a function that returns an interface by an <code><a class="el" href="classSRef.html">SRef</a></code> is assigned into an <code>SPtr</code>. Since it is the job of the <code><a class="el" href="classSRef.html">SRef</a></code> class to preserve the reference count of the plug-in through a function return, the <code>SPtr</code> "takes over" this reference by calling <code><a class="el" href="classSRef.html#a4">SRef::detach()</a></code>. See the description of <code><a class="el" href="classSRef.html">SRef</a></code> for more details.
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>in</em>&nbsp;</td><td>A reference to an <code><a class="el" href="classSRef.html">SRef</a></code> object. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a name="a4" doxytag="SPtr::SPtr"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
<b>template&lt;class T&gt; </b></td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> <b>SPtr&lt; T &gt;::SPtr</b> </td>
          <td class="md" valign="top"><b>(&nbsp;</b></td>
          <td class="md" nowrap valign="top"><b>const SPtr&lt; T &gt; &amp;</b>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;<b> <em>in</em>          </td>
          <td class="md" valign="top"><b>)&nbsp;<b></td>
          <td class="md" nowrap><b></b><code><b> [inline]</b></code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This constructor creates an empty (NULL) smart pointer.
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>in</em>&nbsp;</td><td>A reference to another <code>SPtr</code> of the same type. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a name="a5" doxytag="SPtr::~SPtr"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
<b>template&lt;class T&gt; </b></td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> <b>SPtr&lt; T &gt;::~SPtr</b> </td>
          <td class="md" valign="top"><b>(&nbsp;</b></td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top"><b>)&nbsp;<b></td>
          <td class="md" nowrap><b></b><code><b> [inline]</b></code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This is the destructor of the <code>SPtr</code> class. If the internal pointer is not <code>NULL</code>, then it calls <code><a class="el" href="classIBase.html#a2">IBase::release()</a></code> to remove the reference on the plug-in instance.     </td>
  </tr>
</table>
<hr><h2>Member Function Documentation</h2>
<a name="a7" doxytag="SPtr::createInstance"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
<b>template&lt;class T&gt; </b></td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> <b>void SPtr&lt; T &gt;::createInstance</b> </td>
          <td class="md" valign="top"><b>(&nbsp;</b></td>
          <td class="md" nowrap valign="top"><b>const char *</b>&nbsp;</td>
          <td class="mdname" nowrap>&nbsp;<b> <em>classID</em>, </b></td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><b><a class="el" href="classIBase.html">IBase</a> *</b>&nbsp;</td>
          <td class="mdname" nowrap>&nbsp;<b> <em>reserved</em> = NULL</td>
        </tr>
        <tr>
          <td></td>
          <td class="md"><b> )&nbsp;</b></td>
          <td class="md" colspan="2"><b></b><code><b> [inline]</b></code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This function takes in the name of a plug-in. It passes this name to the plug-in manager to create a new instance of the requested plug-in. It requests an interface pointer of type <code>T</code>. If the plug-in does not implement that interface, the new plug-in instance will be deleted, and the internal pointer of the <code>SPtr</code> is set to remain unchanged. If this function is successful, the internal pointer is set to the interface pointer of type <code>T</code> from the plug-in instance.
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>classID</em>&nbsp;</td><td>A <code>NULL</code> terminated string representing the name of the plug-in to create.</td></tr>
    <tr><td valign=top><em>reserved</em>&nbsp;</td><td>This parameter is for advanced plug-in usage. Normally it should be set to <code>NULL</code> (the default). </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a name="a17" doxytag="SPtr::detach"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
<b>template&lt;class T&gt; </b></td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> <b>T * SPtr&lt; T &gt;::detach</b> </td>
          <td class="md" valign="top"><b>(&nbsp;</b></td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top"><b>)&nbsp;<b></td>
          <td class="md" nowrap><b></b><code><b> [inline]</b></code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This function is used to pass control of the interface pointer out of the smart pointer class. It sets its internal pointer to <code>NULL</code> and returns the original value. The reference count is left unchanged.     </td>
  </tr>
</table>
<a name="a18" doxytag="SPtr::getRef"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
<b>template&lt;class T&gt; </b></td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> <b>T * SPtr&lt; T &gt;::getRef</b> </td>
          <td class="md" valign="top"><b>(&nbsp;</b></td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top"><b>)&nbsp;<b></td>
          <td class="md" nowrap><b></b><code><b> [inline]</b></code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This function increments the reference count of the plug-in instance and returns the value of the <code>T</code> pointer. It is primarily used in a function that returns an interface pointer via an output parameter. The result of <code><a class="el" href="classSPtr.html#a18">getRef()</a></code> is suitable for assigning into the output paramater variable. This maintains consistancy with the rule that all interface pointers passed out of a function call must have their reference count incremented by one.     </td>
  </tr>
</table>
<a name="a8" doxytag="SPtr::operator T *&"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
<b>template&lt;class T&gt; </b></td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> <b>SPtr&lt; T &gt;::operator T *&amp;</b> </td>
          <td class="md" valign="top"><b>(&nbsp;</b></td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top"><b>)&nbsp;<b></td>
          <td class="md" nowrap><b> const</b><code><b> [inline]</b></code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This operator is invoked under several circumstances. Among the interesting ones are:
<p>
<ul>
<li>When the smart pointer is used as an output parameter that takes the form <code>T *&amp;out</code> (where T is the interface type). For these output parameters, an instance of a smart pointer of type T can be used directly as though it were a raw pointer of the appropriate type. If the types don't match, a compiler error is issued.</li></ul>

<p>
<ul>
<li>When the smart pointer is being used as a pointer (for example, passed into a fuction via an input parameter of the form <code>T *in</code>). </li></ul>
    </td>
  </tr>
</table>
<a name="a16" doxytag="SPtr::operator!="></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
<b>template&lt;class T&gt; </b></td>
        </tr>
        <tr>
          <td class="md" colspan="4">
<b>template&lt;class U&gt; </b></td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> <b>template&lt; class U &gt; bool SPtr&lt; T &gt;::operator!=</b> </td>
          <td class="md" valign="top"><b>(&nbsp;</b></td>
          <td class="md" nowrap valign="top"><b>const SPtr&lt; U &gt; &amp;</b>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;<b> <em>in</em>          </td>
          <td class="md" valign="top"><b>)&nbsp;<b></td>
          <td class="md" nowrap><b> const</b><code><b> [inline]</b></code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This operator returns <code>true</code> if the pointers are not the same; otherwise it returns <code>false</code>.
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>in</em>&nbsp;</td><td>A reference to another <code>SPtr</code> of arbitrary type. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a name="a10" doxytag="SPtr::operator->"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
<b>template&lt;class T&gt; </b></td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> <b>T * SPtr&lt; T &gt;::operator-&gt;</b> </td>
          <td class="md" valign="top"><b>(&nbsp;</b></td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top"><b>)&nbsp;<b></td>
          <td class="md" nowrap><b> const</b><code><b> [inline]</b></code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This operator is used to access the member functions of the <code>T</code> interface. It allows the smart pointer to be used with the same syntax as a raw pointer. For example, if <code>myFunction()</code> is a member function of the <code>IMyInterface</code> class:
<p>
<pre>
   SPtr&lt;IMyInterface&gt;	plugin("MyPlugin");
   
   plugin-&gt;myFunction();
   </pre>
     </td>
  </tr>
</table>
<a name="a14" doxytag="SPtr::operator<"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
<b>template&lt;class T&gt; </b></td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> <b>bool SPtr&lt; T &gt;::operator&lt;</b> </td>
          <td class="md" valign="top"><b>(&nbsp;</b></td>
          <td class="md" nowrap valign="top"><b>const SPtr&lt; T &gt; &amp;</b>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;<b> <em>in</em>          </td>
          <td class="md" valign="top"><b>)&nbsp;<b></td>
          <td class="md" nowrap><b> const</b><code><b> [inline]</b></code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This operator returns true if this object is considered to be less than the argument.
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>in</em>&nbsp;</td><td>A reference to another <code>SPtr</code> of the same type. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a name="a13" doxytag="SPtr::operator="></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
<b>template&lt;class T&gt; </b></td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> <b>T * SPtr&lt; T &gt;::operator=</b> </td>
          <td class="md" valign="top"><b>(&nbsp;</b></td>
          <td class="md" nowrap valign="top"><b>const <a class="el" href="classSRef.html">SRef</a>&lt; T &gt; &amp;</b>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;<b> <em>in</em>          </td>
          <td class="md" valign="top"><b>)&nbsp;<b></td>
          <td class="md" nowrap><b></b><code><b> [inline]</b></code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This assigment operator takes in an <code><a class="el" href="classSRef.html">SRef</a></code> of a matching interface type. This is usually invoked when a function that returns an interface by an <code><a class="el" href="classSRef.html">SRef</a></code> is assigned into an <code>SPtr</code>. Since it's the job of the <code><a class="el" href="classSRef.html">SRef</a></code> class to preserve the reference count of the plug-in through a function return, the <code>SPtr</code> "takes over" this reference by calling <code><a class="el" href="classSRef.html#a4">SRef::detach()</a></code>. See the description of <code><a class="el" href="classSRef.html">SRef</a></code> for more details.
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>in</em>&nbsp;</td><td>A reference to an <code><a class="el" href="classSRef.html">SRef</a></code> object. </td></tr>
  </table>
</dl>

<p>
Reimplemented in <a class="el" href="classSQPtr.html#a13">SQPtr</a>.    </td>
  </tr>
</table>
<a name="a12" doxytag="SPtr::operator="></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
<b>template&lt;class T&gt; </b></td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> <b>T * SPtr&lt; T &gt;::operator=</b> </td>
          <td class="md" valign="top"><b>(&nbsp;</b></td>
          <td class="md" nowrap valign="top"><b>const SPtr&lt; T &gt; &amp;</b>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;<b> <em>in</em>          </td>
          <td class="md" valign="top"><b>)&nbsp;<b></td>
          <td class="md" nowrap><b></b><code><b> [inline]</b></code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Reimplemented in <a class="el" href="classSQPtr.html#a12">SQPtr</a>.    </td>
  </tr>
</table>
<a name="a11" doxytag="SPtr::operator="></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
<b>template&lt;class T&gt; </b></td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> <b>T * SPtr&lt; T &gt;::operator=</b> </td>
          <td class="md" valign="top"><b>(&nbsp;</b></td>
          <td class="md" nowrap valign="top"><b>T *</b>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;<b> <em>in</em>          </td>
          <td class="md" valign="top"><b>)&nbsp;<b></td>
          <td class="md" nowrap><b></b><code><b> [inline]</b></code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This function takes in a raw interface pointer. It adds a reference to the instance (via the <code><a class="el" href="classIBase.html#a1">IBase::addRef()</a></code> function) and stores the pointer value in its internal pointer field.
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>in</em>&nbsp;</td><td>A pointer to an interface of type <code>T</code>. </td></tr>
  </table>
</dl>

<p>
Reimplemented in <a class="el" href="classSQPtr.html#a11">SQPtr</a>.    </td>
  </tr>
</table>
<a name="a15" doxytag="SPtr::operator=="></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
<b>template&lt;class T&gt; </b></td>
        </tr>
        <tr>
          <td class="md" colspan="4">
<b>template&lt;class U&gt; </b></td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> <b>bool template&lt; class U &gt; SPtr&lt; T &gt;::operator==</b> </td>
          <td class="md" valign="top"><b>(&nbsp;</b></td>
          <td class="md" nowrap valign="top"><b>const SPtr&lt; U &gt; &amp;</b>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;<b> <em>in</em>          </td>
          <td class="md" valign="top"><b>)&nbsp;<b></td>
          <td class="md" nowrap><b> const</b><code><b> [inline]</b></code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This operator returns <code>true</code> if the pointers are the same; otherwise it returns <code>false</code>.
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>in</em>&nbsp;</td><td>A reference to another <code>SPtr</code> of arbitrary type. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a name="a19" doxytag="SPtr::ptr"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
<b>template&lt;class T&gt; </b></td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> <b>T * SPtr&lt; T &gt;::ptr</b> </td>
          <td class="md" valign="top"><b>(&nbsp;</b></td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top"><b>)&nbsp;<b></td>
          <td class="md" nowrap><b> const</b><code><b> [inline]</b></code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This function simply returns the pointer value of the internal interface pointer. It is usually used to pass the interface pointer into functions where the conversion operators will not be invoked, such as <code>printf()</code>.     </td>
  </tr>
</table>
<a name="a6" doxytag="SPtr::release"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
<b>template&lt;class T&gt; </b></td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> <b>void SPtr&lt; T &gt;::release</b> </td>
          <td class="md" valign="top"><b>(&nbsp;</b></td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top"><b>)&nbsp;<b></td>
          <td class="md" nowrap><b></b><code><b> [inline]</b></code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This function releases the reference on the underlying plug-in instance (see <code><a class="el" href="classSPtr.html#a5">SPtr::~SPtr()</a></code>) and sets the internal pointer to <code>NULL</code>. It is primarily used to clear a smart pointer prior to being reused, for example, as an output parameter in an interator.     </td>
  </tr>
</table>
<hr>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="oaCommonSPtr_8h-source.html">oaCommonSPtr.h</a><li><a class="el" href="oaCommonSPtr_8inl.html">oaCommonSPtr.inl</a><li><a class="el" href="oaCommonSPtr_8dox.html">oaCommonSPtr.dox</a></ul>
<p class="noprint"><a href="#pagetop">Return to top of page</a></p>
<div style="text-align:center">
<br /><img src='../oafooter.gif'><br />

</div>
<br />
<p class='copyright'><a href="../base/titlecopy.html">Copyright &#169; 2002 - 2010 Cadence Design Systems, Inc.</a>
<br />
All Rights Reserved.</p>
</body>
</html>
