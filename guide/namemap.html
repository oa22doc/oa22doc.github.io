<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/html40/loose.dtd"> 

<!-- start header -->

<html><head>

<title>OpenAccess 2.2 API</title>

<link href="../style.css" rel="stylesheet" type="text/css">

<link href="../print.css" rel="stylesheet" type="text/css" media="print">

</head>

<body bgColor=#ffffff><a name="pagetop"></a>

<div id="navigation">

<table border='0' cellpadding='0' cellspacing='0' width = "760">

  <tr>

    <td><img src='../oaheader.gif' alt='../oaheader.gif'></td>

  </tr>

</table>

<table border='0' cellpadding='0' cellspacing='0' width = "760">

  <tr>

    <td width = "95" height = "30"><a href="../index.html"><img src='../topics.gif' alt='../topics.gif' width = "95" height = "30" border="0" align="top"></a></td>

    <td width = "95" height = "30"><a href="../classes.html"><img src='../classes_all.gif' alt='../classes.gif' width = "95" height = "30" border="0"></a></td>

    <td width = "95" height = "30"><a href="../classes_sel.html"><img src='../classes_sel.gif' alt='../classes.gif' width = "95" height = "30" border="0"></a></td>

    <td width = "95" height = "30" ><a href="../exceptionsByName.html"><img src='../exceptions.gif' alt='../exceptions.gif' border="0" ></a></td>

	<td width = "95" height = "30"><a href="index.html"><img src='../progguide.gif' alt='../progguide.gif' width = "95" height = "30" border="0"></a></td>

    <td width = "95" height = "30"><a href="../schema/schematoc.html"><img src='../infomodel.gif' alt='../infomodel.gif' width = "95" height = "30" border="0"></a></td>

    <td width = "95" height = "30"><a href="../doc_index.html"><img src='../index.gif' alt='../index.gif' width = "95" height = "30" border="0"></a></td>

    <td width = "95" height = "30"><a href="../help.html"><img src='../help.gif' alt='../help.gif' border="0" ></a></td>

</tr>

  <tr>

    <td width = "95" height = "20"></td>

    <td width = "95" height = "20"></td>

    <td width = "95" height = "20"></td>

    <td width = "95" height = "20"></td>

    <td width = "95" height = "20"></td>

    <td width = "95" height = "20"></td>

    <td width = "95" height = "20"></td>

    <td width = "95" height = "20"></td>

  </tr>

</table>

</div>

<p>

<!-- end header -->

<h1><a name="pagetop"></a>Name Mapping
</h1>
<hr />
<p> <em class="ul">Names are not simply strings.</em> All names are
represented by a string PLUS the &quot;name space&quot; where the rules for
interpreting that string are defined. A <em>name space</em> refers to one set
of rules for creating and interpreting legal names within an
application. <em>Name mapping</em> applies consistent, predictable naming
conventions to transform names between different name spaces. The standard
algorithmic one-to-one name mapping implemented in the OpenAccess database
ensures that names can be mapped among all name spaces, that names do not
collide, and that the meaning of names is not altered when they are
mapped.</p>

<p>Often, applications use one given name space everywhere to make calls, 
access names, and so on. Other applications allow users to set the name space 
where they want to work, or can work in different name spaces at different 
times, depending on the task they are performing. The OpenAccess database 
supports a number of name spaces. When you use the OpenAccess API, any time 
you use or retrieve a name string, you specify in which name space this string 
belongs.</p>

<p>It is possible for programmers to design their own namespaces for
OpenAccess to use. For guidelines on how to do this see the topic
<a href="derivingnamespaces.html">Deriving Your Own Name Space</a>.</p>

<ul>
<li><a href="#1">The Name Mapping Challenge</a></li>
<li><a href="#2">The Name Mapping Algorithm</a></li>
<li><a href="#3">How Name Mapping Works in General</a></li>
<li><a href="#4">Understanding Case Sensitivity</a></li>
<li><a href="#5">Handling Illegal Characters</a></li>
<li><a href="#6">Type of Differences Among Name Spaces</a></li>
<li><a href="#7">Name Mapping Transformations </a></li>
<li><a href="#8">Details of OpenAccess Name Spaces</a></li>
</ul>


<h2 class="spabove"><a name="1">The Name Mapping Challenge</a></h2>

<p class="center"><img src="images/nmxmpl.gif" alt="Ad hoc name mapping fails in a complex flow"></p>

<p class="center"><b>Ad hoc name mapping fails in a complex flow</b></p>


<p class="w14above">Name mapping can be a challenge because 
different applications use different rules for forming names. Because it 
is critical for design flows to use names to reference a given object at 
different places in the design flow, it is also critical for a database to 
understand the name space where a name is used.</p>

<p>Some systems do not deal with name mapping internally; they are designed to 
simply use the names they receive and do no name manipulation 
inside the database. In this case, it is the user's responsibility to ensure 
that names are treated consistently.</p>

<p>The OpenAccess database includes name mapping capabilities. The 
responsibility for mapping names does not need to take place within the 
applications in the flow, but rather is handled by the database. The 
management of names is part of the OpenAccess database itself, so the 
database always understands what name space a name came from and can always 
appropriately change that name when you write it.</p>

<p>Even though the OpenAccess database maps names between applications 
automatically, understanding name mapping helps you recognize how names can 
change when you use data from other applications.</p>

<p>When you have to enter names in multiple places in a design flow where the 
names must match each other, you need to know how to form the corresponding 
name in multiple name spaces. For example:</p>

<ul>
<li>If you are working with a library name that is used in VHDL, you use the 
VHDL name space.</li>

<li>If you subsequently use netlists that contain Verilog designs, you use 
the Verilog name space.</li>

<li>The library definition in the <code>cds.lib</code> file is in the UNIX name 
space.</li>
</ul>

<p>In other words, a library called <code class="red">MYLIB</code> in VHDL is 
subsequently used in Verilog as <code class="red">mylib</code>. This library 
must be defined in the <code>cds.lib</code> file with a statement such as:</p>

<pre>
	DEFINE mylib /usr/libs/mylibdir 
</pre>

<p>OpenAccess overcomes the name mapping difficulties by including a name 
mapping interface right in the database to avoid forcing the name mapping into the flow.</p>

<p class="center"><img src="images/oadbflow.gif" alt="Database-centric flow with name mapping in database interface"></p>

<p class="center"><b>Database-centric flow with name mapping in database interface</b></p>


<h3 class="w16above"><a name="2">The Name Mapping Algorithm</a></h3>

<p>OpenAccess uses algorithmic name mapping to map names between different name 
spaces.</p>

<ul>
<li>Names can be mapped from one name space to another using the legal name 
plus the source and destination name spaces. The algorithm does not use 
auxiliary information such as design specific mapping tables. The algorithm 
is designed to be context-free so that no information about the design is 
necessary to perform the mapping.</li>

<li>Every name that is legal in one name space maps to a legal name in every 
other.</li>

<li>Every pair of names that are different names in one name space map to 
different names in every other name space.</li>

<li>All mappings are reversible. Mapping a name from one name space to 
another and then back to the original name space always results in the 
original name, with the possible exception of a loss of case if the original 
name space is case insensitive.</li>
</ul>

<p class="indent"><b>NOTE</b>:<br />
Algorithmic name mapping does not solve certain problems such as mapping 
names to another representation where the design has been modified.</p>


<h2 class="w18above"><a name="3">How Name Mapping Works in General</a></h2>

<p>To properly handle the variety of names in different tools, each 
application applies the correct name space for each file format it handles. 
A port or pin of an instance might be called 
<code class="red">i1/addr&lt;3:0&gt;</code> on a schematic. In Verilog, this name 
becomes <code class="red">i1.addr[3:0]</code>, and in VHDL it becomes 
<code class="red">i1:addr(3 downto 0)</code>. Each part of these names has 
a specific meaning.</p>

<table border=1 cellpadding=5 cellspacing=5 summary="&nbsp;">
<tr>
<th>Name Item</th>
<th>Explanation </th>
</tr>

<tr>
<td>i1</td>
<td>An identifier (an instance name in this case)</td>
</tr>

<tr>
<td>slash (&nbsp;/&nbsp;), period (&nbsp;.&nbsp;), colon (&nbsp;:&nbsp;)</td>
<td>A hierarchy delimiter</td>
</tr>

<tr>
<td>addr</td>
<td>An identifier (a port/pin name in this case)</td>
</tr>

<tr>
<td>&lt;3:0&gt;, [3:0], (3 downto 0)</td>
<td>A vector expression </td>
</tr>
</table>


<h3 class="w18above"><a name="4">Understanding Case Sensitivity</a></h3>

<p>The majority of EDA tools are case sensitive. However, VHDL and the Windows 
file system (Win) are case-insensitive name spaces.</p>

<p>To provide a one-to-one mapping between case-sensitive and case-insensitive
name spaces, case cannot be preserved in this mapping. For example, if a 
Verilog name <code class="red">StopGap</code> were to become 
<code class="red">StopGap</code> in VHDL, and if the Verilog name 
<code class="red">stopgap</code> were to become 
<code class="red">stopgap</code> in VHDL, then two different Verilog names 
would become a single VHDL name.</p>

<p>To handle this situation, OpenAccess name mapping rules map all 
case-insensitive letters as lowercase case-sensitive letters. Case-sensitive 
uppercase letters map to escaped names in VHDL. In the Win name space, the 
algorithm precedes them with a percent sign (&nbsp;%&nbsp;), so that the 
Verilog name <code class="red">GORP</code> becomes 
<code class="red">%G%O%R%P</code>.</p>


<h3 class="w16above"><a name="5">Handling Illegal Characters</a></h3>

<p>If a name contains characters that are illegal in the destination name 
space (even in any escaped form that name space may have), the algorithm uses 
character encoding to map the names. Characters that are illegal in the 
destination name space are replaced with a pound sign (&nbsp;#&nbsp;) followed 
by the character value encoded as two hexadecimal digits (0-9 or a-f; for 
example, <code class="red">#2a</code>. The name <code class="red">a*b</code> 
is represented as <code class="red">a#2ab</code> in a name space that does not 
support the asterisk (&nbsp;*&nbsp;).</p>


<h3 class="w16above"><a name="6">Types of Differences Among Name Spaces</a></h3><p>Keywords, case sensitivity, character set indexing, and hierarchy are handled differently in different name spaces. The following table shows some examples of how these components are handled.</p><table border=1 cellspacing=5 cellpadding=5 summary="&nbsp;"><tr><th>Differences</th><th>Examples of Name Space Rules</th></tr><tr><td>Keywords</td><td>The string <code class="red">and</code> is a keyword in Verilog and VHDL, while <code class="red">process</code> is a keyword in VHDL but not in Verilog. Many name spaces have no keywords, such as CDBA and UNIX.</td></tr><tr><td>Case Sensitivity</td><td>In VHDL, the name <code class="red">aaa</code> refers to the same object as <code class="red">AAA</code>. In CDBA or UNIX, these names are different. </td></tr><tr><td>Syntax and Characters</td><td>Many name spaces have an alternative way to include characters in names that would otherwise be illegal. In VHDL, <code class="red">\a+b*\</code> is a legal name because the backslashes (&nbsp;\&nbsp;) escape the characters that are otherwise illegal. A normal Verilog name can contain a dollar sign (&nbsp;$&nbsp;), but a VHDL name cannot unless it is escaped.</td></tr><tr><td>Bit Indices</td><td>Some name spaces have a way to indicate a name that is a particular bit of a vector. The syntax for these names and the characters used to set off the bit index from the rest of the name are different in different name spaces. The syntax for indicating a range of names in a vector also varies among name spaces. For example, <code class="red">&lt;4&gt;</code>, <code class="red">[4]</code>, and <code class="red">(4)</code> are all ways that certain name spaces use to indicate bit <code class="red">4</code> of a vector. In some name spaces, the bit index character can be set by the caller.</td></tr><tr><td>Hierarchy</td><td>When using hierarchical designs, different name spaces use different hierarchy separators to indicate the hierarchical levels of a name. Theslash character (&nbsp;/&nbsp;) and period character (&nbsp;.&nbsp;) are common hierarchy characters. In some name spaces, the hierarchy character can be set by the caller.</td></tr></table><h3 class="w16above"><a name="7">Name Mapping Transformations </a></h3><p>OpenAccess uses the following name mapping patterns when it implements a namespace:</p><ul><li>As much as possible, names are not modified. For example, the name <code class="red">abc</code> is left the same in every supported name space.</li><li>When a name contains a character that is illegal in the name space to which it is being mapped (even using escaping), the algorithm uses the hex value for the character. For example, a character with the hex value of <code class="red">2d</code> (a minus sign) becomes <code class="red">#2d</code>.</li><li>When case-insensitive names are converted to a case-sensitive name space, the letters are set to lowercase.</li><li>When case-sensitive names are mapped to a case-insensitive name space, they are left untouched if they are lowercase. If they are uppercase, the algorithm creates escaped names if the name space has a case-sensitive escaped form, such as in VHDL.</li><li>If an escaped name that is legal and is a different name when the escape characters are omitted is mapped to a name space where there is not a similar escaped form, the algorithm prepends the characters <code class="red">ESC_</code> to the mapped name. For example, in VHDL, <code class="red">\aaa\</code> is a different name from <code class="red">aaa</code>, so they cannot both map to <code class="red">aaa</code> in Verilog. The name mapping rules map a VHDL <code class="red">\aaa\</code> to <code class="red">ESC_aaa</code> in Verilog.</li><li>Length restrictions are not handled by these name mapping rules. The mapping routines can handle full hierarchical names up to 8024 characters long; each member can be up to 256 characters long.</li></ul><p>In the following examples, the <img src="images/space.gif" align="absbottom"alt="blank space">&nbsp; character in Verilog names is used to clearly document a blank space.</p><h4 class="w16above"><a name="ex">Examples of Name Mapping</a></h4><table border=1 summary="&nbsp;"><tr><th>Type</th><td><a href="#9">Native</a></td>
<td><a href="#10">VHDL</a></td>
<td><a href="#11">Verilog</a></td>
<td><a href="#12">CDBA</a></td>
<td><a href="#13">LEF/DEF</a></td>
<td><a href="#14">SPEF</a></td>
<td><a href="#15">SPF</a></td>
<td><a href="#16">UNIX</a></td>
<td><a href="#16">Win</a></td>
<td><a href="#17">Spice</a></td>
</tr>

<tr>
<td>lowercase or case insensitive</td>
<td>bigchip</td>
<td>bigchip<br>BIGCHIP</td>
<td>bigchip</td>
<td>bigchip</td>
<td>bigchip</td>
<td>bigchip</td>
<td>bigchip</td>
<td>bigchip</td>
<td>bigchip<br />BIGCHIP</td>
<td>bigchip<br>BIGCHIP</td>
</tr>

<tr>
<td>case sensitive mixed case</td>
<td>BigChip</td>
<td>\BigChip\</td>
<td>BigChip</td>
<td>BigChip</td>
<td>BigChip</td>
<td>BigChip</td>
<td>BigChip</td>
<td>BigChip</td>
<td>%Big%Chip</td>
<td>%Big%Chip</td>
</tr>

<tr>
<td>keyword</td>
<td>and</td>
<td>\and\</td>
<td>\and<img src="images/space.gif" align="absbottom"
alt="blank space"></td>
<td>and</td>
<td>and</td>
<td>and</td>
<td>and</td>
<td>and</td>
<td>and</td>
<td>and</td>
</tr>

<tr>
<td>unneeded escape</td>
<td>ESC_trash</td>
<td>\trash\</td>
<td>ESC_trash</td>
<td>ESC_trash</td>
<td>ESC_trash</td>
<td>ESC_trash</td>
<td>ESC_trash</td>
<td>ESC_trash</td>
<td>%E%S%C_trash</td>
<td align=center bgcolor="#FFFFFF">ESC_trash</td>
</tr>

<tr>
<td>embedded space</td>
<td>foo bar</td>
<td>\foo bar\</td>
<td>\foo#20bar<img src="images/space.gif" align="absbottom"
alt="blank space"></td>
<td>foo#20bar</td>
<td>foo%20bar</td>
<td>foo#20bar</td>
<td>foo#20bar</td>
<td>foo#20bar</td>
<td>foo#20bar</td>
<td>foo#20bar</td>
</tr>

<tr>
<td>device names</td>
<td>aux</td>
<td>aux</td>
<td>aux</td>
<td>aux</td>
<td>aux</td>
<td>aux</td>
<td>aux</td>
<td>aux</td>
<td>%%aux</td>
<td>aux</td>
</tr>

<tr>
<td>back-slash</td>
<td>\a\b</td>
<td>\\\a\\b\</td>
<td>\\a\b<img src="images/space.gif" align="absbottom"
alt="blank space"></td>
<td>#5ca#5cb</td>
<td>\\a\\b</td>
<td>\\a\\b</td>
<td>\\a\\b</td>
<td>#5ca#5cb</td>
<td>#5ca#5cb</td>
<td>#5ca#5cb</td>
</tr>

<tr>
<td>bit index</td>
<td align=center>[&nbsp;]</td>
<td align=center>(&nbsp;)</td>
<td align=center>[&nbsp;]</td>
<td align=center>&lt;&nbsp;&gt;</td>
<td align=center>[&nbsp;]</td>
<td align=center>[&nbsp;]</td>
<td align=center bgcolor="#e0e0e0"><em>scalar only by default</em></td>
<td align=center bgcolor="#e0e0e0"><em>not<br>applicable</em></td>
<td align=center bgcolor="#e0e0e0"><em>not<br>applicable</em></td>
<td align=center>[&nbsp;]</td>
</tr>

<tr>
<td>hierarchy</td>
<td align=center>/</td>
<td align=center>:</td>
<td align=center><b>.</b></td>
<td align=center>`&nbsp;</td>
<td align=center>/</td>
<td align=center>/</td>
<td align=center>/</td>
<td align=center bgcolor="#e0e0e0"><em>not<br>applicable</em></td>
<td align=center bgcolor="#e0e0e0"><em>not<br>applicable</em></td>
<td align=center><b>.</b></td>
</tr>

<tr>
<td>forward slash</td>
<td>#2fa#2fb</td>
<td>\/a/b\</td>
<td>\/a/b<img src="images/space.gif" align="absbottom"
alt="blank space"></td>
<td>#2fa#2fb</td>
<td>\/a\/b</td>
<td>\/a\/b</td>
<td>\/a\/b</td>
<td>#2fa#2fb</td>
<td>#2fa#2fb</td>
<td>a/b</td>
</tr>

<tr>
<td>special characters*</td>
<td>a&lt;1#3a2&gt;</td>
<td>\a&lt;1:2&gt;\</td>
<td>\a&lt;1:2&gt;<img src="images/space.gif" align="absbottom"
alt="blank space"></td>
<td>a#3c1:2#3e</td>
<td>a&lt;1:2&gt;</td>
<td>a\&lt;\:2\&gt;</td>
<td>a&lt;1\:2&gt;</td>
<td>a#3c1#3a2#3e</td>
<td>a#3c1#3a2#3e</td>
<td>a<1:2></td>
</tr>
</table>


<p>*&nbsp; &nbsp; Although the special characters look similar to a name 
with an index expression, this row shows a name, with special characters, 
that is being used as an atomic name. The 
<img src="images/space.gif" align="absbottom"
alt="blank space"> character indicates a blank space.</p>


<h3 class="w16above"><a name="8">Details of OpenAccess Name Spaces</a></h3>

<p>OpenAccess natively supports the following name spaces:</p>

<ul>
<li><a href="#9">Native</a></li>
<li><a href="#10">VHDL</a></li>
<li><a href="#11">Verilog</a></li>
<li><a href="#12">CDBA</a></li>
<li><a href="#13">LEF/DEF</a></li>
<li><a href="#14">SPEF</a></li>
<li><a href="#15">SPF</a></li>
<li><a href="#16">UNIX and Windows</a></li>
<li><a href="#17">Spice</a></li>
</ul>


<h4 class="w16above"><a name="9">Native Name Space</a></h4>

<p>The general-purpose Native name space is case sensitive. This name space 
supports all types of names: hierarchical, scalar, vectorBit, vector, stepped, 
and bundle. There are no keywords in the Native name space. This name space 
does not support an escaped form.</p>

<p>All alphanumeric characters and symbols are allowed as Native normal names 
except the open bracket (&nbsp;[&nbsp;), close bracket (&nbsp;]&nbsp;), 
forward slash (&nbsp;/&nbsp;), colon (&nbsp;:&nbsp;), asterisk (&nbsp;*&nbsp;),
pound (&nbsp;#&nbsp;), and comma (&nbsp;,&nbsp;).</p>

<p>When the hex delimiter appears in a Native name, it must be followed by 
two hex digits.  The hex digits must only encode illegal characters or the 
hex delimiter in the Native name space.</p>
<p>For bundle names, commas (&nbsp;,&nbsp;) are used to separate the elements in the bundle. Also, any element can have a repeat count expressed as an integer and an asterisk (&nbsp;*&nbsp;) at the beginning of the name. If a bundle name is hierarchical, the hierarchy must be expressed on each element of the bundle name. For example, if the original bundle name is </p>
<pre>2*U,V[2],V[4:5]</pre>
<p>then in a hierarchy (say A1/B1), this name can be specified as</p>
<pre>2*A1/B1/U,A1/B1/V[2],A1/B1/V[4:5]</pre>
<h4 class="w16above"><a name="10">VHDL Name Space</a></h4>

<p>Each VHDL name is either in the normal form, <code class="red">ABC</code>, 
or the escaped form <code class="red">\ABC\</code>. Most names in a VHDL 
design are VHDL normal names. This name space does not support stepped or 
bundle names.</p>


<div class="indent">
<h4>VHDL Normal Names</h4>

<p>VHDL normal names are case insensitive. This means that the name 
<code class="red">AbC</code> and the name <code class="red">abc</code> are 
equivalent, and refer to the same object. VHDL normal names can contain 
letters, digits, or the underscore character. The first character must be a 
letter. All alphanumeric characters are allowed as VHDL normal names. The 
only symbol that is allowed is the underscore. The space is not allowed.</p>

<h4>VHDL Escaped Names</h4>

<p>VHDL escaped names are case sensitive, unlike normal VHDL names. Escaped 
names always begin and end with a backslash (&nbsp;\&nbsp;). This means that 
the name <code class="red">\AbC\</code> and the name 
<code class="red">\aBc\</code> refer to two different objects.</p>

<p>A name in the VHDL normal name space and the same name in the VHDL escaped 
name space do not represent the same object. For example, the VHDL name 
<code class="red">abc</code> and <code class="red">\abc\</code> refer to two 
different objects. To embed a backslash in an escaped name, use double 
backslashes.</p>

<p>If the original name was in the VHDL escaped form even though it was legal 
in the VHDL normal form, it must be returned to the escaped form, not the 
normal form. For example, <code class="red">\abc\</code> maps to CDBA 
<code class="red">ESC_abc</code>, and it maps back to 
<code class="red">\abc\</code> in VHDL.</p>

<p>All alphanumeric characters and symbols, as well as spaces, are allowed as 
VHDL escaped names.</p>

<p><a href="notvhdlkeywds.html">	VHDL93 Keywords Not Allowed as VHDL Normal Identifiers</a></p>
</div>


<h4 class="w16above"><a name="11">Verilog Name Space</a></h4>

<p>Each Verilog name is either in the normal form, 
<code class="red">ABC</code>, or the escaped form 
<code class="red">\ABC<img src="images/space.gif" align="absbottom"
alt="blank space"></code>. (<strong>Note: </strong>In this document, the <img src="images/space.gif" 
align="absbottom" alt="blank space">&nbsp; character in Verilog names 
is used to clearly document a blank space.) Most names in a Verilog design are Verilog normal 
names. If you need to represent names that are illegal as Verilog normal 
names, use the Verilog escaped name space. For example, the name 
<code class="red">and</code> in the CDBA name space maps to the Verilog 
escaped name <code class="red">\and</code><img src="images/space.gif" 
align="absbottom" alt="blank space"> because <code class="red">and</code> 
is a Verilog keyword. All Verilog names are case sensitive. This means that 
the name <code class="red">AbC</code> and the name <code class="red">abc</code> 
refer to two different objects. This name space does not support stepped or 
bundle names.</p>


<div class="indent">
<h4>Verilog Normal Names</h4>

<p>Verilog normal names can contain letters, digits, the underscore character, 
and the dollar sign (&nbsp;$&nbsp;). The first character cannot be a digit or 
a dollar sign. All letters and digits are allowed as Verilog normal names. The 
space is not allowed.</p>


<h4>Verilog Escaped Names</h4>

<p>Verilog escaped names always begin with a backslash (&nbsp;\&nbsp;) and end 
with a space. Verilog escaped names are also case sensitive. This means that 
the name <code class="red">\AbC<img src="images/space.gif" align="absbottom"
alt="blank space"></code> 
and the name 
<code class="red">\aBc<img src="images/space.gif" align="absbottom"
alt="blank space"></code>
refer to two different objects.</p>

<p>Although any name can be escaped, only those names that might not be 
represented in the Verilog normal name space due to character restrictions or 
keywords must be escaped. A name in the Verilog normal name space and the 
exact same name in the Verilog escaped name space represent the same object. 
For example, the Verilog name <code class="red">abc</code> and 
<code class="red">\abc<img src="images/space.gif" align="absbottom"
alt="blank space"></code> refer 
to the same object.</p>

<p>All alphanumeric characters and symbols are allowed in Verilog escaped 
names.</p>

<p><a href="notverilogkeywds.html">Keywords Not Allowed as Verilog Identifiers</a></p>
</div>


<h4><a name="12">CDBA Name Space</a></h4>

<p>CDBA  names are case sensitive. This means that the name 
<code class="red">AbC</code> and the name <code class="red">abc</code> 
refer to two different objects. There are no keywords in CDBA. This name 
space supports all types of names: hierarchical, scalar, vectorBit, vector, 
stepped, and bundle. This name space does not support an escaped form.</p>

<p>All alphanumeric characters and symbols are allowed as CDBA  names 
except the comma (&nbsp;,&nbsp;), backslash (&nbsp;\&nbsp;), forward slash 
(&nbsp;/&nbsp;), colon (&nbsp;:&nbsp;), back tick (`), and opening (&nbsp;&lt;&nbsp;) and 
closing (&nbsp;&gt;&nbsp;) angle brackets. Leading and trailing spaces are 
allowed, but embedded spaces are not. Opening and closing parentheses are 
allowed if they are not preceded by a delimiter and only if they enclose 
digits.</p>
<h5>Hierarchical Names</h5>
<p>CDBA-based applications (that support physical hierarchy) represent physical hierarchy from multiple oaDesigns  with a slash (/). However, this form of hierarchy representation is not provided by the OpenAccess name-mapping functions. The OpenAccess CDBA namespace uses a back tick (`) as the hierarchy delimiter instead, and most applications regard this as a flattened name without hierarchy. It is the responsibility of the application to manage this. </p>
<div class="indent">

  <h5>Using Vector Expressions in Multiple-Bit Net Names</h5>
  <p>A multiple-bit net name can be a bundle, a bus, or a combination of both. 
You can improve readability in your designs by shortening multiple-bit net 
names.</p>

<p>To indicate that multiple bits of one net carry similar information, give 
each bit the same base name, then add a suffix to each bit name to distinguish 
the signals.</p>

<p>For example, to show four bits of a net with a common base name 
(<code>DATA</code>), but with individual suffixes (<code>&lt;0&gt;</code>, 
<code>&lt;1&gt;</code>, <code>&lt;2&gt;</code>, and <code>&lt;3&gt;</code>), 
assign the following names:</p>

<pre>
	DATA&lt;0&gt;
	DATA&lt;1&gt;
	DATA&lt;2&gt;
	DATA&lt;3&gt;
</pre>

<h5 class="w14above">Using Vector Expressions in Multiple Signals</h5>
<p>To name a wire that contains multiple signals with the same base name, 
specify the base name followed by a vector expression. The vector expression 
can be:</p>

<ul>
<li>A list of the individual bit numbers separated by commas and enclosed 
with angle brackets.<br /><br />

<div class="indent">
For example, <code>DATA&lt;2,1,0&gt;</code> represents 
<code>DATA&lt;2&gt;</code>, <code>DATA&lt;1&gt;</code>, and 
<code>DATA&lt;0&gt;</code>.<br /><br />
</div></li>

<li>A range of numbers containing a lower and upper bound and, optionally, an 
increment value. The numbers are separated with colons and enclosed with angle 
brackets.<br /><br />

<div class="indent">
<p>For example, <code>DATA&lt;1:7:2&gt;</code> represents</p>

<pre class="code">
DATA&lt;1&gt;, DATA&lt;3&gt;, DATA&lt;5&gt;, DATA&lt;7&gt;
</pre>

<p>Use a positive integer for <code>incrValue</code>. If you do not specify 
an increment value, the default is <code>1</code>.</p>
</div></li></ul>

<p>The ordering of the bits in a bus is important when you are connecting the 
bus to a pin that has a width greater than 1.</p>


<h5 class="w16above">Evaluating Vector Expressions in Multiple-Bit Net Names</h5>
<p>The system evaluates vector expressions in multiple-bit net names as 
follows:</p>

<ul>
<li>The vector expression <code>DATA&lt;0:3:2&gt;</code> names a 2-bit bus 
containing <code>DATA&lt;0&gt;</code> and <code>DATA&lt;2&gt;</code>.</li>

<li>The vector expression <code>DATA&lt;1:3:2&gt;</code> names a 2-bit bus 
containing <code>DATA&lt;1&gt;</code> and <code>DATA&lt;3&gt;</code>.</li>

<li>The vector expressions <code>DATA&lt;0:3&gt;</code> and 
<code>DATA&lt;0:3:1&gt;</code> are equivalent names that generate a 4-bit bus 
containing <code>DATA&lt;0&gt;</code>, <code>DATA&lt;1&gt;</code>, 
<code>DATA&lt;2&gt;</code>, and <code>DATA&lt;3&gt;</code>.</li>

<li>The vector expression <code>DATA&lt;2:0&gt;</code> generates a 3-bit bus 
that contains <code>DATA&lt;2&gt;</code>, <code>DATA&lt;1&gt;</code>, and 
<code>DATA&lt;0&gt;</code>.</li>
</ul>

<h5 class="w16above">Using Prefix Repeat Operators in Multiple-Bit Net Names</h5>
<p>A multiple-bit net name can be a bundle, a bus, or a combination of the 
two. You can improve readability in your designs by shortening multiple-bit 
net names.</p>

<p>You can repeat a single signal name, a group of signal names, or a vector 
term any number of times in the net name by placing a prefix repeat operator 
&lt;<em>*n&gt;</em> in front of the name, where <em>n</em> is a positive integer 
that defines the number of times to repeat each bit in the vector term.</p>

<ul>
<li>Use the prefix repeat operator &lt;<em>*n</em>&gt; to repeat a single-signal 
name. The following equivalent net names both name the same four-bit net:

<pre>
	&lt;*2&gt;A,B,C
	A,A,B,C
</pre></li>

<li>Use the prefix repeat operator <em>&lt;*n</em>&gt; and parentheses to repeat 
a group of signal names. The following two net names are equivalent:

<pre>
	&lt;*2&gt;(A,B),C
	A,B,A,B,C
</pre></li>

<li>Use combinations of the prefix repeat operator <em>&lt;*n</em>&gt; and 
parentheses to nest parenthetical expressions to any required depth. Nested 
expressions are expanded from the innermost expression outward. For example, 
a name with the expression <code>&lt;*2&gt;(A,&lt;*2&gt;(X,Y)),B</code> 
expands to <code>A,X,Y,X,Y,A,X,Y,X,Y,B</code>.</li>
</ul>


<h5 class="w16above">Using Suffix Repeat Operators in Multiple-Bit Net Names</h5>
<p>A multiple-bit net name can be a bundle, a bus, or a combination of both. 
You can improve readability in your designs by shortening multiple-bit net 
names using vector expressions.</p>

<p>A suffix repeat operator is a number, &lt;<em>*n</em>&gt;, after a vector 
term, where <em>n</em> is a positive integer that defines the number of times to 
repeat each bit in the vector term.</p>

<ul>
<li>Use the suffix repeat operator &lt;<em>*n&gt;</em> to repeat each bit in a 
group of bit names before expanding the vector term. For example, the following 
three names all describe the same six-bit net:

<pre>
	A&lt;0:2*2&gt;
	A&lt;0*2,1*2,2*2&gt;
	A&lt;0,0,1,1,2,2&gt;
</pre></li>

<li>Use the suffix repeat operator &lt;<em>*n&gt;</em> and parentheses to repeat
the sequence of bit names. In this case, the vector term is expanded before 
the bits are repeated. The following names all describe the same six-bit net:

<pre>
	A&lt;(0:2)*2&gt;
	A&lt;0:2,0:2&gt;
	A&lt;0,1,2,0,1,2&gt;
</pre></li>
</ul>
</div>


<h4 class="w18above"><a name="13">LEF/DEF Name Space</a></h4>

<p>The LEF name space is case sensitive, with programmable bus characters. 
There are no keywords, as keywords in LEF are position sensitive. This name 
space does not support hierarchical, vector, stepped or bundle names.</p>

<p>The DEF name space is case sensitive, with programmable bus characters and 
a programmable hierarchy character. The default bus characters are opening 
(&nbsp;[&nbsp;) and closing (&nbsp;]&nbsp;) square brackets. The default 
hierarchy character is a forward slash (&nbsp;/&nbsp;). This name space does 
not support vector, stepped, or bundle names. There are no keywords, as 
keywords in DEF are position sensitive.</p>

<p>With the exception of the space character, the newline character, and the 
semicolon (&nbsp;;&nbsp;), names containing characters that are illegal in 
the LEF and DEF name spaces can be escaped using the backslash (&nbsp;\&nbsp;) 
character. This is a single-character escape, so each non-normal character 
must be escaped individually. If a bus delimiter or hierarchy character is 
escaped, it loses it meaning regarding busses or hierarchy and is just 
another character in the name.</p>
<p>The LEF/DEF name space does not support  multi-bit names. An oacVectorNameInvalid exception is thrown if the LEF/DEF name space is used to get a string from a vector name. An oacBundleNameInvalid exception is thrown if the LEF/DEF name space is used to get a string from a bundle name.</p>
<p>In addition, the LEF name space does not support hierarchical names or indexed names. oacHierNameInvalid and oacIndexedNameInvalid exceptions are thrown respectively. </p>
<p>A name with a double vector notation (name[1][2])  becomes a vectorBitName with the first bus notation escaped internally (name\[1\][2]).</p>
<p>A name with a bus notation in the middle of the name  becomes a scalarName with the bus notation escaped (name[1]a becomes name\[1\]a internally).</p>
<p> When getting the string from the name, the escaping is undone, so you get the original name back.</p>
<p>&nbsp;</p>
<h4 class="w18above"><a name="14">SPEF Name Space</a></h4>

<p>The SPEF name space is case sensitive, with a programmable pin delimiter
character, hierarchy character, and bus delimiter characters. Since the SPEF
name space describes scalar connectivity, there is no bit delimiter or
repeat operator.</p>

<p>SPEF normal names can include all alphanumeric characters, the underscore
character (&nbsp;_&nbsp;), and the declared delimiter characters without
escaping. This name space does not support vector, stepped, or bundle names.
There are no keywords.</p>


<p>The pin delimiter separates the instance and terminal portions of a path name.
The period (&nbsp;.&nbsp), forward slash (&nbsp;/&nbsp;), colon (&nbsp;:&nbsp;),
or pipe (&nbsp;|&nbsp;) characters can be used as a pin delimiter. The default
pin delimiter character is a colon (&nbsp;:&nbsp;).</p>

<p>The hierarchy character delimits the hierarchy. The period (&nbsp;.&nbsp),
forward slash (&nbsp;/&nbsp;), colon (&nbsp;:&nbsp;), or pipe (&nbsp;|&nbsp;)
characters can be used as a hierarchy delimiter. The default hierarchy delimiter
character is a forward slash (&nbsp;/&nbsp;).</p>

<p>The bus delimiter characters specify the opening and closing bus values.
The following characters can be used as bus delimiters:</p>

<div class="indent">

<table border=0 cellspacing="5" cellpadding="5" summary="&nbsp;">
<tr>
<td><strong>Open</strong></td>
<td>{</td>
<td>(</td>
<td>&lt;</td>
<td>:</td>
<td>.</td>
<td>[</td>
</tr>

<tr>
<td><strong>Close</strong></td>
<td>}</td>
<td>)</td>
<td>&gt;</td>
<td>:</td>
<td>.</td>
<td>]</td>
</tr>
</table>
</div>

<p>The default bus characters are the opening (&nbsp;[&nbsp;) and closing
(&nbsp;]&nbsp;) square brackets. The bus delimiter characters cannot be the same
as the hierarchy or pin delimiter characters. The closing bus character must be
paired with the corresponding opening bus character. If the opening bus character
is a colon (&nbsp;:&nbsp;) or a period (&nbsp;.&nbsp;), the closing bus character
can be omitted.</p>
<p>The SPEF name space does not support multi-bit names. An oacVectorNameInvalid exception is thrown if the SPEF name space is used to get a string from a vector name. An oacBundleNameInvalid exception is thrown if the SPEF name space is used to get a string from a bundle name.</p>
<p>The backslash (&nbsp;\&nbsp;) is the escape character in the SPEF name space.
This is a single-character escape, so each non-normal character must be escaped
individually. If a bus delimiter or hierarchy character is escaped, it loses it
meaning regarding busses or hierarchy and is just another character in the name.
An escaped regular character simply maps to itself. The following special
characters must be escaped on a character-by-character basis in the SPEF name
space:</p>

<pre>
 &quot; ! # $ % &amp; ' ( ) * + , - . / : ; &lt; = &gt; ? @ [ \ ] ^ { } ~
</pre>
<p>A name with a double vector notation (name[1][2])  becomes a vectorBitName with the first bus notation escaped internally (name\[1\][2]).</p>
<p>A name with a bus notation in the middle of the name  becomes a scalarName with the bus notation escaped (name[1]a becomes name\[1\]a internally).</p>
<p> When getting the string from the name, the escaping is undone, so you get the original name back.</p>
<h4 class="w18above"><a name="15">SPF Name Space</a></h4>
<p>The SPF name space is case sensitive, with a programmable pin delimiter
character, hierarchy character, and bus delimiter characters. Since the SPF
name space describes scalar connectivity, there is no bit delimiter or
repeat operator.</p>

<p>SPF normal names can include all alphanumeric characters, the underscore
(&nbsp;_&nbsp;), and the declared delimiter characters without escaping. Spaces,
tabs, and newline characters are not allowed. This name space does not support
vector, stepped, or bundle names. There are no keywords.</p>

<p>The pin delimiter separates the instance and terminal portions of a path
name. Any printable character can be used as a pin delimiter. The default pin
delimiter character is a colon (&nbsp;:&nbsp;).</p>

<p>The hierarchy character delimits the hierarchy. Any printable character can
be used as a hierarchy delimiter. The default hierarchy delimiter character is
a forward slash (&nbsp;/&nbsp;).</p>

<p>The bus delimiter characters specify the opening and closing bus values. Any
printable character can be used as a bus delimiter. There is no default bus
delimiter character. If no bus delimiter characters are defined, no names are
interpreted as bus bits.</p>
<p>The SPF name space does not support multi-bit names. An oacVectorNameInvalid exception is thrown if the SPF name space is used to get a string from a vector name. An oacBundleNameInvalid exception is thrown if the SPF name space is used to get a string from a bundle name.</p>
<p>The backslash (&nbsp;\&nbsp;) is the escape character in the SPF name space.
This is a single-character escape, so each non-normal character must be escaped
individually. If a bus delimiter or hierarchy character is escaped, it loses it
meaning regarding busses or hierarchy and is just another character in the name.
An escaped regular character simply maps to itself. The following special
characters must be escaped on a character-by-character basis in the SPF name
space:</p>

<pre>
 &quot; ! # $ % &amp; ' ( ) * + , - . / : ; &lt; = &gt; ? @ [ \ ] ^ { } ~
</pre>


<h4 class="w18above"><a name="16">UNIX and Windows Name Spaces</a></h4>

<p>In the <a href="libstruc.html#fileSys">FileSys DM system</a>, cell names and view names are written as directories using the appropriate
name space for each file system. For cells and views stored on UNIX systems,
this is the UNIX namespace. For cell and views stored on windows systems, this 
is the Windows namespace.</p>


<div class="indent">

<h4>UNIX Name Space</h4>

<p>The UNIX name space is used for library names in lib.defs files. It is also 
used for cell and view directory names in libraries that are stored on UNIX 
systems. This name space does not support hierarchical, indexed, vector, 
stepped, or bundle names. The UNIX name space follows the rules for creating 
directory names on UNIX systems, except that it is more restrictive. Many 
characters, such as the period (&nbsp;.&nbsp;) and the comma (&nbsp;,&nbsp;) 
that are legal in the file system are not allowed in the UNIX name space.</p>

<p>The UNIX name space is a case sensitive name space; for example, the 
filenames <code class="red">abc</code> and <code class="red">AbC</code> refer 
to different directories.</p>

<p>All alphanumeric characters plus the underscore (&nbsp;_&nbsp;), at sign 
(&nbsp;@&nbsp;), and pound sign (&nbsp;#&nbsp;) are allowed in UNIX names.</p>

<p>UNIX uses the pound sign (&nbsp;#&nbsp;) followed by two hex digits to map 
characters that are otherwise illegal.</p>
<p>The Unix name space does not support multi-bit names. An oacVectorNameInvalid exception is thrown if the Unix name space is used to get a string from a vector name. An oacBundleNameInvalid exception is thrown if the Unix name space is used to get a string from a bundle name. In addition, hierarchical names or indexed names are not supported. oacHierNameInvalid and oacIndexedNameInvalid exceptions are thrown respectively. </p>
<h4 class="w16above">Windows Name Space</h4>

<p>The Windows name space is used for cell and view subdirectories on Windows 
libraries. Windows is a case-insensitive name space, but case-preserving. 
This means the filenames <code class="red">abc</code> and 
<code class="red">AbC</code> are the same file, and only one of them can 
exist in any given directory. This name space does not support hierarchical, 
indexed, vector, stepped, or bundle names.</p>

<p>The Windows name space allows digits, the underscore character 
(&nbsp;_&nbsp;), the at sign (&nbsp;@&nbsp;), the percent sign 
(&nbsp;%&nbsp;) if followed by an uppercase letter or keyword, and the pound 
sign (&nbsp;#&nbsp;). Several names are reserved by Windows. These can be 
thought of as keywords that are illegal names. The keywords are:</p>

<pre>
	aux
	con
	com0 - com9
	lpt0 - lpt9
	nul
	prn
</pre>

<p>Windows uses the pound sign (&nbsp;#&nbsp;) followed by two hex digits to 
map characters that are otherwise illegal.</p>

<p>Windows uses the percent sign (&nbsp;%&nbsp;) to map case-sensitive 
uppercase letters. An <code class="red">X</code> in Verilog becomes 
<code class="red">%X</code> in Windows.</p>

<p>Windows also uses the percent sign (&nbsp;%&nbsp;) to map names that would 
otherwise look like reserved names. For example, a cell named 
<code class="red">lpt4</code> in a UNIX library is called 
<code class="red">%%lpt4</code> in a Windows library.</p>
<p>The Windows name space does not support multi-bit names. An oacVectorNameInvalid exception is thrown if the Windows name space is used to get a string from a vector name. An oacBundleNameInvalid exception is thrown if the Windows name space is used to get a string from a bundle name. In addition, hierarchical names or indexed names are not supported. oacHierNameInvalid and oacIndexedNameInvalid exceptions are thrown respectively.</p>
</div>


<h4 class="w18above"><a name="17">Spice Name Space</a></h4>

<p>The Spice name space is case insensitive and case preserving. The name space supports hierarchical, scalar, and vectorBit names. This name space does not have keywords since 
keywords in Spice are position sensitive. This name space does not support vector or bundle names. </p>

<p>Spice normal names must begin with an alphabetical character or one of the
following symbols: </p>
<pre>
 # ! _ %
</pre>

<p>To map two unequal strings from a case sensitive name space to two unequal names in oaSpiceNS, the % character is used as an upper case delimiter. The strings <code>abc</code> and <code>Abc</code> in nativeNS map respectively to <code>abc</code> and <code>%Abc</code> in oaSpiceNS.</p>

<p>If a name is initialized in oaSpiceNS with the strings <code>%Abc</code> or <code>%abc</code>, this is mapped to <code>Abc</code> in a case sensitive name space such as oaNativeNS. If the % character is followed by an alphabetical character, the alphabetical character is mapped to an uppercase alphabetical character in any other case sensitive name space. If the % character is followed by any other character, for example a numeric such as <code>%1Abc</code> from a Spice name, it is mapped to <code>%1abc</code> in oaNativeNS.</p>

<p>Spice normal names can include all alphanumeric characters and the following
symbols: </p>
<pre>
 + - * / : ; $ # ! &lt; &gt; _ % [ ]
</pre>

<p>When a string ends with the open (&nbsp;[&nbsp;) and close (&nbsp;]&nbsp;) 
  square brackets enclosing nothing but digits, the &nbsp;[&nbsp; and &nbsp;]&nbsp; are 
interpreted as bus delimiter characters in Spice. The string is interpreted as a vectorBit name in this case. On the other hand, a string with square brackets that enclose characters other than digits is interpreted as a scalar name in Spice. For example, the string 'a[0]' is a 
    vectorBit name in Spice, while the string 'a[abc]' and 'a[4:3] are just scalar names 
    in Spice.</p>
<p>The Spice name space does not support  multi-bit names. An oacVectorNameInvalid exception is thrown if the Spice name space is used to get a string from a vector name. An oacBundleNameInvalid exception is thrown if the Spice name space is used to get a string from a bundle name.</p>
<p>The hierarchy character (&nbsp;.&nbsp;), delimits the hierarchy.  </p>

<p>The Spice name space uses the pound sign (&nbsp;#&nbsp;) followed by two
hex digits to map characters that are otherwise illegal.</p>

<!-- <h2>How to Use the OpenAccess Name Mapping Functions</h2> -->



<!-- beginning of footer -->
<br /><br /><br /><br />

<p><a href="#pagetop">Return to top of page</a></p>

<p><a href="index.html">Return to Programmers Guide topics</a></p>

<div style="text-align: center">
<img src="../pgfooter.gif"><br />

</div><br />

<p><a href="../base/titlecopy.html">Copyright &#169; 2001-2010 Cadence Design Systems, Inc.</a>
<br />All rights reserved.</p>
</body>
</html>
